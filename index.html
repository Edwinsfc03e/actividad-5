<!-- <!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Brazo Robótico 3DOF 2D (sin rotación base)</title>
  <style>
    body {
      background: #f2f2f2;
      display: flex;
      flex-direction: column;
      align-items: center;
      font-family: Arial, sans-serif;
      margin: 0;
      height: 100vh;
      justify-content: center;
    }

    canvas {
      background: white;
      border: 2px solid #333;
      border-radius: 10px;
    }

    .controls {
      margin-top: 20px;
      background: #fff;
      padding: 15px 25px;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }

    label {
      display: block;
      margin: 8px 0 4px;
      font-weight: bold;
    }
  </style>
</head>
<body>

  <canvas id="robotCanvas" width="700" height="450"></canvas>

  <div class="controls">
    <label>Ángulo brazo 1 (°): <span id="arm1Val">45</span></label>
    <input type="range" id="arm1" min="-90" max="90" value="45">

    <label>Ángulo brazo 2 (°): <span id="arm2Val">-30</span></label>
    <input type="range" id="arm2" min="-90" max="90" value="-30">

    <label>Ángulo herramienta (°): <span id="toolVal">0</span></label>
    <input type="range" id="tool" min="-90" max="90" value="0">
  </div>

  <script>
    const canvas = document.getElementById('robotCanvas');
    const ctx = canvas.getContext('2d');

    // Longitudes de los segmentos
    const baseHeight = 60;
    const L1 = 120; // brazo 1
    const L2 = 100; // brazo 2
    const L3 = 60;  // herramienta

    // Sliders
    const arm1Slider = document.getElementById('arm1');
    const arm2Slider = document.getElementById('arm2');
    const toolSlider = document.getElementById('tool');

    const arm1Val = document.getElementById('arm1Val');
    const arm2Val = document.getElementById('arm2Val');
    const toolVal = document.getElementById('toolVal');

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const originX = canvas.width / 2;
      const originY = canvas.height - 50;

      const θ1 = parseFloat(arm1Slider.value) * Math.PI / 180;
      const θ2 = parseFloat(arm2Slider.value) * Math.PI / 180;
      const θ3 = parseFloat(toolSlider.value) * Math.PI / 180;

      arm1Val.textContent = arm1Slider.value;
      arm2Val.textContent = arm2Slider.value;
      toolVal.textContent = toolSlider.value;

      // Base
      ctx.fillStyle = "#555";
      ctx.fillRect(originX - 30, originY - baseHeight, 60, baseHeight);

      const baseX = originX;
      const baseY = originY - baseHeight;

      // Cinemática directa (sin rotación base)
      const elbowX = baseX + L1 * Math.cos(θ1);
      const elbowY = baseY - L1 * Math.sin(θ1);

      const wristX = elbowX + L2 * Math.cos(θ1 + θ2);
      const wristY = elbowY - L2 * Math.sin(θ1 + θ2);

      const handX = wristX + L3 * Math.cos(θ1 + θ2 + θ3);
      const handY = wristY - L3 * Math.sin(θ1 + θ2 + θ3);

      // Dibujo
      ctx.lineWidth = 8;

      // Brazo 1
      ctx.strokeStyle = "#0077cc";
      ctx.beginPath();
      ctx.moveTo(baseX, baseY);
      ctx.lineTo(elbowX, elbowY);
      ctx.stroke();

      // Brazo 2
      ctx.strokeStyle = "#00cc66";
      ctx.beginPath();
      ctx.moveTo(elbowX, elbowY);
      ctx.lineTo(wristX, wristY);
      ctx.stroke();

      // Herramienta
      ctx.strokeStyle = "#cc0000";
      ctx.beginPath();
      ctx.moveTo(wristX, wristY);
      ctx.lineTo(handX, handY);
      ctx.stroke();

      // Pivotes
      ctx.fillStyle = "black";
      [[baseX, baseY], [elbowX, elbowY], [wristX, wristY], [handX, handY]].forEach(([x, y]) => {
        ctx.beginPath();
        ctx.arc(x, y, 5, 0, Math.PI * 2);
        ctx.fill();
      });

      // Línea de suelo
      ctx.strokeStyle = "#aaa";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, originY);
      ctx.lineTo(canvas.width, originY);
      ctx.stroke();
    }

    arm1Slider.oninput = arm2Slider.oninput = toolSlider.oninput = draw;
    draw();
  </script>

</body>
</html> -->

<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Brazo 3R — DH, T0^3, Ejes y Denavit-Hartenberg (interactivo)</title>
<style>
  body{font-family:system-ui,Arial; background:#f4f4f6; margin:0; display:flex; flex-direction:column; align-items:center; gap:12px;}
  #wrap{display:flex; gap:18px; width:100%; max-width:1250px; padding:16px; box-sizing:border-box;}
  canvas{background:#fff; border-radius:12px; box-shadow:0 6px 20px rgba(0,0,0,.08);}
  .panel{background:#fff; padding:12px 14px; border-radius:10px; box-shadow:0 4px 14px rgba(0,0,0,.06); max-height:720px; overflow:auto;}
  .controls label{display:block; font-weight:600; margin-top:8px;}
  input[type=range]{width:280px;}
  table.dh{border-collapse:collapse; width:100%; margin-top:6px;}
  table.dh th, table.dh td{border:1px solid #ddd; padding:6px 8px; font-size:13px; text-align:center;}
  pre.box{background:#f7f9fb; padding:8px; border-radius:6px; font-size:13px; overflow:auto;}
  .small{font-size:12px; color:#444}
  .row{display:flex; gap:12px;}
  .col{flex:1;}
  .checkbox{margin-top:8px}
</style>
</head>
<body>

<h2 style="margin:12px 0 0">Brazo 3R — DH, Transformación, Ejes y Denavit-Hartenberg (interactivo)<br>
Actividad Robotica Ingenieria electronica Edwin Herney Fonseca Triana</h2>

<div id="wrap">
  <div class="panel" style="flex:1 1 650px; display:flex; flex-direction:column; align-items:center;">
    <canvas id="c" width="820" height="560"></canvas>
    <div style="margin-top:10px; width:100%; display:flex; justify-content:center;">
      <div class="controls">
        <label>Modo: <span id="modeLabel">Base activa</span></label>
        <label class="checkbox"><input type="checkbox" id="lockBase"> Bloquear rotación base (usar brazo fijo como antes)</label>

        <label>θ1 (rotación base) ° — rango ±150: <span id="t1v">0</span></label>
        <input id="t1" type="range" min="-150" max="150" value="0">

        <label>θ2 (brazo inferior) ° — rango [-130, +17.5]: <span id="t2v">45</span></label>
        <input id="t2" type="range" min="-130" max="17.5" value="45" step="0.5">

        <label>θ3 (brazo superior) ° — rango [-110, +145]: <span id="t3v">-30</span></label>
        <input id="t3" type="range" min="-110" max="145" value="-30" step="0.5">

        <label>d (altura base) : <span id="dv">60</span> px (parámetro d)</label>
        <input id="d" type="range" min="0" max="160" value="60">

        <label>L1 (longitud eslabón 1): <span id="L1v">120</span> px</label>
        <input id="L1" type="range" min="20" max="220" value="120">

        <label>L2 (longitud eslabón 2): <span id="L2v">100</span> px</label>
        <input id="L2" type="range" min="20" max="220" value="100">
      </div>
    </div>
  </div>

  <div class="panel" style="width:520px;">
    <h3 style="margin:2px 0 6px">Tabla DH (convención estándar)</h3>
    <table class="dh">
      <thead><tr><th>i</th><th>a_i</th><th>α_i</th><th>d_i</th><th>θ_i (variable)</th></tr></thead>
      <tbody>
        <tr><td>1</td><td>0</td><td>+90°</td><td>d</td><td>θ1 (±150°)</td></tr>
        <tr><td>2</td><td>L1</td><td>0°</td><td>0</td><td>θ2 (−130°..+17.5°)</td></tr>
        <tr><td>3</td><td>L2</td><td>0°</td><td>0</td><td>θ3 (−110°..+145°)</td></tr>
      </tbody>
    </table>

    <h3 style="margin-top:10px">Matrices elementales A<sub>i</sub> (DH)</h3>
    <pre id="Ablocks" class="box small"></pre>

    <h3>Transformación compuesta T<sub>0</sub><sup>3</sup></h3>
    <pre id="T03" class="box small"></pre>

    <h3>Posición efector final (x,y,z)</h3>
    <pre id="pos" class="box small"></pre>

    <h3>Matriz de Rotación R (submatriz 3×3)</h3>
    <pre id="Rmat" class="box small"></pre>

    <h3>Denavit-Hartenberg</h3>
    <pre id="Jmat" class="box small"></pre>

    <div style="margin-top:6px;" class="small">
      <strong>Notas:</strong> cada vez que mueves un slider la figura, ejes, matrices y Denavit-Hartenberg se actualizan. Los ejes z<sub>i-1</sub> se obtienen de las matrices de transformación intermedias (columna 3 de R).
    </div>
  </div>
</div>

<script>
function matMul(A,B){
  const m=A.length,n=B[0].length,p=B.length;
  const C = Array.from({length:m},()=>Array(n).fill(0));
  for(let i=0;i<m;i++) for(let k=0;k<p;k++) for(let j=0;j<n;j++) C[i][j]+=A[i][k]*B[k][j];
  return C;
}
function degToRad(d){return d*Math.PI/180;}
function fmtMat(M,prec=4){ return M.map(r=>r.map(v=>Number(v).toFixed(prec)).join('\t')).join('\n'); }
function vecAdd(a,b){return a.map((v,i)=>v+b[i]);}
function vecSub(a,b){return a.map((v,i)=>v-b[i]);}
function cross(a,b){return [ a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0] ];}

const canvas=document.getElementById('c');
const ctx=canvas.getContext('2d');
const t1=document.getElementById('t1'), t2=document.getElementById('t2'), t3=document.getElementById('t3'),
      L1in=document.getElementById('L1'), L2in=document.getElementById('L2'), din=document.getElementById('d'),
      lockBase=document.getElementById('lockBase');

const t1v=document.getElementById('t1v'), t2v=document.getElementById('t2v'), t3v=document.getElementById('t3v'),
      L1v=document.getElementById('L1v'), L2v=document.getElementById('L2v'), dv=document.getElementById('dv');

const Ablocks=document.getElementById('Ablocks'), T03=document.getElementById('T03'),
      posOut=document.getElementById('pos'), Rmat=document.getElementById('Rmat'), Jmat=document.getElementById('Jmat'),
      modeLabel=document.getElementById('modeLabel');

function A_DH(a,alpha, d, theta){
  const ca=Math.cos(alpha), sa=Math.sin(alpha), ct=Math.cos(theta), st=Math.sin(theta);
 

// configuracion Dh y calculos para dar respuestas 
  return [
    [ct, -st*ca,  st*sa, a*ct],
    [st,  ct*ca, -ct*sa, a*st],
    [0,     sa,     ca,  d],
    [0,     0,      0,   1]
  ];
}

/*  cálculo directo (matrices)  */
function forward(theta1,theta2,theta3, L1, L2, d){
  // parámetros DH:
  const a1=0, alpha1=Math.PI/2, d1=d, th1=theta1;
  const a2=L1, alpha2=0, d2=0, th2=theta2;
  const a3=L2, alpha3=0, d3=0, th3=theta3;

  const A1=A_DH(a1,alpha1,d1,th1);
  const A2=A_DH(a2,alpha2,d2,th2);
  const A3=A_DH(a3,alpha3,d3,th3);

  const T01 = matMul(A1, [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]]).map(r=>r.slice(0,4)); // A1 itself
  const T12 = A2, T23 = A3;

  const T0_1 = A1;
  const T0_2 = matMul(T0_1, A2);
  const T0_3 = matMul(T0_2, A3);

  function posFromT(T){ return [T[0][3], T[1][3], T[2][3]]; }
  const p0=[0,0,0];
  const p1=posFromT(T0_1), p2=posFromT(T0_2), p3=posFromT(T0_3);

  const z0=[0,0,1];
  const z1 = [ T0_1[0][2], T0_1[1][2], T0_1[2][2] ];
  const z2 = [ T0_2[0][2], T0_2[1][2], T0_2[2][2] ];

  const Jv1 = cross(z0, vecSub(p3, p0));
  const Jv2 = cross(z1, vecSub(p3, p1));
  const Jv3 = cross(z2, vecSub(p3, p2));
  const J = [
    [Jv1[0], Jv2[0], Jv3[0]],
    [Jv1[1], Jv2[1], Jv3[1]],
    [Jv1[2], Jv2[2], Jv3[2]]
  ];
  const Jw = [z0, z1, z2]; 

  return {A1,A2,A3, T0_1, T0_2, T0_3, p0,p1,p2,p3, z0,z1,z2, J, Jw};
}

/*dibujo en canvas*/
function drawAll(state){
  const cw=canvas.width, ch=canvas.height;
  ctx.clearRect(0,0,cw,ch);

  const originX = 220, originY = ch-60; 

  ctx.strokeStyle="#e0e0e0"; ctx.lineWidth=2;
  ctx.beginPath(); ctx.moveTo(0, originY+24); ctx.lineTo(cw, originY+24); ctx.stroke();

  ctx.fillStyle="#555"; ctx.fillRect(originX-30, originY - state.d, 60, state.d);

  const pbase = [originX, originY - state.d, 0]; 

  function mapPt(p){ return [ originX + p[0], originY - p[2] ]; }

  const p1 = mapPt(state.p1), p2 = mapPt(state.p2), p3 = mapPt(state.p3), p0 = mapPt([0,0,0]);


  ctx.lineWidth=10; ctx.lineCap='round';
  ctx.strokeStyle="#0077cc";
  ctx.beginPath(); ctx.moveTo(p0[0], p0[1]); ctx.lineTo(p1[0], p1[1]); ctx.stroke();


  ctx.strokeStyle="#00cc66"; ctx.beginPath(); ctx.moveTo(p1[0], p1[1]); ctx.lineTo(p2[0], p2[1]); ctx.stroke();


  ctx.strokeStyle="#cc0000"; ctx.beginPath(); ctx.moveTo(p2[0], p2[1]); ctx.lineTo(p3[0], p3[1]); ctx.stroke();

  // dibujo de joins
  [p0,p1,p2,p3].forEach(pt=>{
    ctx.fillStyle="black"; ctx.beginPath(); ctx.arc(pt[0], pt[1],6,0,Math.PI*2); ctx.fill();
  });


  const Rs = [state.T0_1, state.T0_2, state.T0_3];
  const origins = [p0,p1,p2];
  const axlen = 40;
  for(let i=0;i<3;i++){
    const T = Rs[i];
    const o = origins[i];
 
    const rx = [T[0][0], T[1][0], T[2][0]];
    const ry = [T[0][1], T[1][1], T[2][1]];
    const rz = [T[0][2], T[1][2], T[2][2]];
// mapeo de endpoints locales para funcionamiento
    const ex = mapPt([ (T[0][3] + axlen*rx[0]), (T[1][3] + axlen*rx[1]), (T[2][3] + axlen*rx[2]) ]);
    const ey = mapPt([ (T[0][3] + axlen*ry[0]), (T[1][3] + axlen*ry[1]), (T[2][3] + axlen*ry[2]) ]);
    const ez = mapPt([ (T[0][3] + axlen*rz[0]), (T[1][3] + axlen*rz[1]), (T[2][3] + axlen*rz[2]) ]);

    ctx.lineWidth=3;
    ctx.strokeStyle="#ff4d4d"; ctx.beginPath(); ctx.moveTo(o[0],o[1]); ctx.lineTo(ex[0],ex[1]); ctx.stroke();
    ctx.strokeStyle="#28c28a"; ctx.beginPath(); ctx.moveTo(o[0],o[1]); ctx.lineTo(ey[0],ey[1]); ctx.stroke();
    ctx.strokeStyle="#4d79ff"; ctx.beginPath(); ctx.moveTo(o[0],o[1]); ctx.lineTo(ez[0],ez[1]); ctx.stroke();

    ctx.fillStyle="#222"; ctx.font="12px Arial";
    ctx.fillText("x"+i, ex[0]+4, ex[1]+4);
    ctx.fillText("y"+i, ey[0]+4, ey[1]+4);
    ctx.fillText("z"+i, ez[0]+4, ez[1]+4);
  }

  
  ctx.fillStyle="#222"; ctx.font="13px Arial";
  ctx.fillText("x = red, y = green, z = blue", 8, 18);
}

/* actualizar y mostrar datos en panel  */
function updateAndRender(){

  let th1=Number(t1.value), th2=Number(t2.value), th3=Number(t3.value);
  if(lockBase.checked){ th1 = 0; modeLabel.textContent='Base bloqueada (θ1=0)'; } else modeLabel.textContent='Base activa';
  t1v.textContent = (lockBase.checked?0:th1);
  t2v.textContent = Number(th2).toFixed(2);
  t3v.textContent = Number(th3).toFixed(2);
  L1v.textContent = L1in.value;
  L2v.textContent = L2in.value;
  dv.textContent = din.value;

  const r1=degToRad(th1), r2=degToRad(th2), r3=degToRad(th3);
  const L1=Number(L1in.value), L2=Number(L2in.value), d=Number(din.value);

  const res = forward(r1, r2, r3, L1, L2, d);

  Ablocks.textContent =
`A1 =
${fmtMat(res.A1)}
A2 =
${fmtMat(res.A2)}
A3 =
${fmtMat(res.A3)}`;

  // T0^3
  T03.textContent = fmtMat(res.T0_3,5);

  // Positions
  posOut.textContent =
`p0 = [0, 0, 0]
p1 = [${res.p1.map(v=>v.toFixed(4)).join(', ')}]
p2 = [${res.p2.map(v=>v.toFixed(4)).join(', ')}]
p3 = [${res.p3.map(v=>v.toFixed(4)).join(', ')}]`;

  // rotation matrix R from T0_3 top-left 3x3
  const R = [
    [res.T0_3[0][0], res.T0_3[0][1], res.T0_3[0][2]],
    [res.T0_3[1][0], res.T0_3[1][1], res.T0_3[1][2]],
    [res.T0_3[2][0], res.T0_3[2][1], res.T0_3[2][2]]
  ];
  Rmat.textContent = fmtMat(R,5);

  // Denavit-Hartenberg MAtriz 
  const J = res.J;
  const Jw = res.Jw; 
  const Jfull = [
    [J[0][0].toFixed(5), J[0][1].toFixed(5), J[0][2].toFixed(5)],
    [J[1][0].toFixed(5), J[1][1].toFixed(5), J[1][2].toFixed(5)],
    [J[2][0].toFixed(5), J[2][1].toFixed(5), J[2][2].toFixed(5)],
    [Jw[0][0].toFixed(5), Jw[1][0].toFixed(5), Jw[2][0].toFixed(5)], // note: Jw columns need to be arranged as columns; reformat below
  ];
  let Jtxt = "Jv (3x3):\n";
  Jtxt += fmtMat(J,5) + "\n\nJw (3x3 as columns):\n";
  const JwMat = [
    [res.z0[0], res.z1[0], res.z2[0]],
    [res.z0[1], res.z1[1], res.z2[1]],
    [res.z0[2], res.z1[2], res.z2[2]]
  ];
  Jtxt += fmtMat(JwMat,5);
  Jmat.textContent = Jtxt;

  const state = {
    p1: res.p1, p2: res.p2, p3: res.p3, T0_1: res.T0_1, T0_2: res.T0_2, T0_3: res.T0_3,
    d: d
  };
  drawAll(state);
}

// Eventos finales
[t1,t2,t3, L1in, L2in, din, lockBase].forEach(el => el.addEventListener('input', updateAndRender));
updateAndRender();

</script>

<footer>Desarrollado por Edwin Fonseca 2025</footer>
<footer>Ingenieria electronica 2025</footer>
</body>
</html>

